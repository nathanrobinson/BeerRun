# Copilot Instructions for Unity iOS Development with Test-Driven Development

## Project Overview
BeerRun is an 8-bit side-scroller platform game built with Unity, targeting iOS platforms. This document provides comprehensive guidelines for AI-assisted development with emphasis on test-driven development (TDD) practices.

## Development Environment & Setup

### Unity Version & Configuration
- Use Unity LTS versions (2022.3 LTS or newer recommended)
- Configure for iOS deployment with proper platform settings
- Ensure iOS Build Support module is installed
- Set up Xcode integration for iOS builds

### Project Structure
```
Assets/
├── Scripts/
│   ├── Gameplay/          # Core game mechanics
│   ├── UI/               # User interface components
│   ├── Managers/         # System managers (GameManager, AudioManager, etc.)
│   ├── Data/             # ScriptableObjects and data containers
│   ├── Utilities/        # Helper classes and extensions
│   └── Tests/            # All test files
│       ├── EditMode/     # Edit-mode tests
│       └── PlayMode/     # Play-mode tests
├── Scenes/               # Game scenes
├── Prefabs/              # Reusable game objects
├── Materials/            # Unity materials
├── Textures/             # Sprite textures and images
├── Audio/                # Sound effects and music
└── StreamingAssets/      # Platform-specific assets
```

## Test-Driven Development (TDD) Guidelines

### Testing Philosophy
- **Red-Green-Refactor Cycle**: Always write failing tests first, make them pass, then refactor
- **Test Coverage**: Aim for 80%+ code coverage on critical gameplay systems
- **Test Categories**: Use `[Category("Integration")]`, `[Category("Unit")]`, `[Category("Performance")]`
- **Naming Convention**: Use descriptive test names: `When_PlayerJumps_Should_IncreaseVerticalVelocity`

### Unity Test Framework Setup
```csharp
// Example test structure
[TestFixture]
[Category("Unit")]
public class PlayerMovementTests
{
    private GameObject playerGameObject;
    private PlayerController playerController;

    [SetUp]
    public void Setup()
    {
        playerGameObject = new GameObject();
        playerController = playerGameObject.AddComponent<PlayerController>();
    }

    [TearDown]
    public void TearDown()
    {
        Object.DestroyImmediate(playerGameObject);
    }

    [Test]
    public void When_PlayerPressesJumpKey_Should_InitiateJump()
    {
        // Arrange
        bool jumpInitiated = false;
        playerController.OnJumpInitiated += () => jumpInitiated = true;

        // Act
        playerController.HandleJumpInput();

        // Assert
        Assert.IsTrue(jumpInitiated);
    }
}
```

### Testing Best Practices
1. **Isolate Dependencies**: Use dependency injection and mocking
2. **Test Behavior, Not Implementation**: Focus on what the code does, not how
3. **Use Builders**: Create test data builders for complex objects
4. **Mock MonoBehaviour Dependencies**: Use interfaces for testable MonoBehaviour components
5. **Performance Tests**: Include performance benchmarks for critical paths

### Testing Frameworks & Tools
- **Unity Test Framework**: For unit and integration tests
- **NSubstitute**: For mocking dependencies
- **Unity Performance Testing**: For performance benchmarks
- **Addressables Testing**: For asset loading tests

## Unity Development Patterns

### MonoBehaviour Architecture
```csharp
// Use composition over inheritance
public class PlayerController : MonoBehaviour, IPlayerController
{
    [SerializeField] private PlayerMovement movement;
    [SerializeField] private PlayerHealth health;
    [SerializeField] private PlayerInventory inventory;

    public void Initialize(IGameManager gameManager)
    {
        movement.Initialize(this);
        health.Initialize(gameManager.HealthSystem);
        inventory.Initialize(gameManager.InventorySystem);
    }
}
```

### ScriptableObject Data Management
```csharp
[CreateAssetMenu(fileName = "New Level Data", menuName = "BeerRun/Level Data")]
public class LevelData : ScriptableObject
{
    [SerializeField] private int levelNumber;
    [SerializeField] private float difficulty;
    [SerializeField] private List<ObstacleSpawnData> obstacles;
    
    // Provide validation in editor
    private void OnValidate()
    {
        if (difficulty < 0) difficulty = 0;
        if (levelNumber < 1) levelNumber = 1;
    }
}
```

### Event System Implementation
```csharp
// Use UnityEvents for inspector configuration
[System.Serializable]
public class PlayerEvent : UnityEvent<PlayerController> { }

// Use C# events for code-based subscriptions
public static class GameEvents
{
    public static event System.Action<int> OnScoreChanged;
    public static event System.Action<float> OnHealthChanged;
    public static event System.Action OnGameOver;
}
```

## iOS Platform Considerations

### Performance Optimization
```csharp
// Use object pooling for frequently instantiated objects
public class ObjectPool<T> : MonoBehaviour where T : MonoBehaviour
{
    [SerializeField] private T prefab;
    [SerializeField] private int initialSize = 10;
    private Queue<T> pool = new Queue<T>();

    [Test]
    public void Should_ReusePooledObjects()
    {
        // Test object pooling efficiency
        var pool = new ObjectPool<Enemy>();
        var enemy1 = pool.Get();
        pool.Return(enemy1);
        var enemy2 = pool.Get();
        
        Assert.AreSame(enemy1, enemy2);
    }
}
```

### Memory Management
- Use `Object.Destroy()` instead of `DestroyImmediate()` in production
- Implement proper disposal patterns for IDisposable objects
- Cache frequently accessed components
- Use Addressables for large assets

### iOS-Specific Settings
```csharp
#if UNITY_IOS
    // iOS-specific code
    [DllImport("__Internal")]
    private static extern void _ShowLeaderboard();
    
    public void ShowLeaderboard()
    {
        _ShowLeaderboard();
    }
#endif
```

### Touch Input Handling
```csharp
public class TouchInputManager : MonoBehaviour
{
    public static event System.Action<Vector2> OnTouchStarted;
    public static event System.Action<Vector2> OnTouchMoved;
    public static event System.Action OnTouchEnded;

    [Test]
    public void Should_DetectTouchInput()
    {
        var touchManager = new TouchInputManager();
        bool touchDetected = false;
        TouchInputManager.OnTouchStarted += (_) => touchDetected = true;
        
        // Simulate touch
        touchManager.SimulateTouch(Vector2.zero);
        
        Assert.IsTrue(touchDetected);
    }
}
```

## Code Quality Standards

### C# Coding Conventions
- Follow Microsoft C# coding standards
- Use PascalCase for public members, camelCase for private
- Prefix interfaces with 'I': `IPlayerController`
- Use meaningful names: `CalculateJumpForce()` not `CalcJF()`
- Add XML documentation for public APIs

### SOLID Principles Application
```csharp
// Single Responsibility: Each class has one job
public class ScoreManager : IScoreManager
{
    private int currentScore;
    
    public void AddScore(int points) { /* implementation */ }
    public int GetCurrentScore() => currentScore;
}

// Dependency Inversion: Depend on abstractions
public class GameManager : MonoBehaviour
{
    [SerializeField] private GameObject player;
    private IPlayerController playerController;
    private IScoreManager scoreManager;
    
    public void Initialize(IScoreManager scoreManager)
    {
        this.scoreManager = scoreManager;
        playerController = player.GetComponent<IPlayerController>();
    }
}
```

### Error Handling
```csharp
public class SafeComponentAccess
{
    public static T GetComponentSafely<T>(GameObject obj, string context = "") where T : Component
    {
        var component = obj.GetComponent<T>();
        if (component == null)
        {
            Debug.LogError($"Missing {typeof(T).Name} component on {obj.name}. Context: {context}");
        }
        return component;
    }
    
    [Test]
    public void Should_LogErrorWhenComponentMissing()
    {
        var gameObject = new GameObject();
        LogAssert.Expect(LogType.Error, new Regex("Missing.*component"));
        
        var result = SafeComponentAccess.GetComponentSafely<Rigidbody>(gameObject);
        
        Assert.IsNull(result);
    }
}
```

## Testing Strategies

### Unit Testing Approach
```csharp
[TestFixture]
public class InventorySystemTests
{
    private InventorySystem inventory;
    private Mock<IItemDatabase> mockItemDatabase;

    [SetUp]
    public void Setup()
    {
        mockItemDatabase = new Mock<IItemDatabase>();
        inventory = new InventorySystem(mockItemDatabase.Object);
    }

    [Test]
    public void When_AddingItem_Should_IncreaseQuantity()
    {
        // Arrange
        var item = new Item { Id = 1, Name = "Beer" };
        mockItemDatabase.Setup(db => db.GetItem(1)).Returns(item);

        // Act
        inventory.AddItem(1, 5);

        // Assert
        Assert.AreEqual(5, inventory.GetItemQuantity(1));
    }
}
```

### Integration Testing
```csharp
[TestFixture]
[Category("Integration")]
public class GameplayIntegrationTests
{
    [UnityTest]
    public IEnumerator When_PlayerReachesLiquorStore_Should_CompleteLevel()
    {
        // Arrange
        var scene = SceneManager.LoadScene("TestLevel", LoadSceneMode.Additive);
        yield return new WaitForSeconds(0.1f);
        
        var player = GameObject.FindWithTag("Player");
        var liquorStore = GameObject.FindWithTag("LiquorStore");
        
        // Act
        player.transform.position = liquorStore.transform.position;
        yield return new WaitForSeconds(0.5f);
        
        // Assert
        var gameManager = Object.FindObjectOfType<GameManager>();
        Assert.IsTrue(gameManager.IsLevelComplete);
    }
}
```

### Performance Testing
```csharp
[Test, Performance]
public void EnemySpawning_Should_MaintainFrameRate()
{
    using (Measure.Method())
    {
        var spawner = new EnemySpawner();
        for (int i = 0; i < 100; i++)
        {
            spawner.SpawnEnemy();
        }
    }
}
```

## Continuous Integration & Deployment

### Automated Testing Pipeline
```yaml
# Example GitHub Actions workflow
name: Unity Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: game-ci/unity-test-runner@v2
        with:
          unityVersion: 2022.3.12f1
          testMode: all
```

### Build Automation for iOS
- Use Unity Cloud Build or GitHub Actions
- Automate code signing and provisioning profiles
- Include automated testing in CI pipeline
- Generate build reports and test coverage

## Performance Monitoring

### Profiling Guidelines
- Use Unity Profiler regularly during development
- Monitor frame rate on target iOS devices
- Profile memory usage and garbage collection
- Test on various iOS device generations

### Key Performance Metrics
- Target: 60 FPS on iPhone 8 and newer
- Memory usage: < 200MB on iPhone 8
- Load times: < 3 seconds for level transitions
- Battery usage: Minimize background processing

## Security Considerations

### iOS App Store Guidelines
- Follow Apple's App Store Review Guidelines
- Implement proper data privacy measures
- Use secure communication for any network features
- Avoid using deprecated iOS APIs

### Code Protection
- Obfuscate critical game logic
- Use secure storage for sensitive data
- Implement proper authentication if needed

## Documentation Standards

### Code Documentation
```csharp
/// <summary>
/// Manages player movement including jumping, running, and collision detection.
/// Implements test-driven development patterns for reliable gameplay mechanics.
/// </summary>
/// <example>
/// <code>
/// var player = new PlayerController();
/// player.Initialize(gameManager);
/// player.HandleJumpInput();
/// </code>
/// </example>
public class PlayerController : MonoBehaviour, IPlayerController
{
    /// <summary>
    /// Initiates a jump if the player is grounded.
    /// </summary>
    /// <returns>True if jump was successful, false otherwise.</returns>
    public bool HandleJumpInput() { /* implementation */ }
}
```

### Testing Documentation
- Document test scenarios and expected outcomes
- Maintain test coverage reports
- Document known issues and workarounds
- Keep testing guidelines updated

## Common Patterns & Anti-Patterns

### ✅ Good Practices
- Use dependency injection for testability
- Implement proper object pooling
- Cache component references
- Use events for loose coupling
- Write tests before implementation

### ❌ Anti-Patterns to Avoid
- Using `FindObjectOfType()` in Update()
- Not cleaning up event subscriptions
- Hardcoding values instead of using ScriptableObjects
- Writing tests after implementation
- Ignoring iOS-specific performance considerations

## Debugging & Troubleshooting

### Common iOS Issues
- Touch input not working: Check Input System configuration
- Performance drops: Profile and optimize heavy operations
- Build failures: Verify Xcode and iOS SDK versions
- Crashes on device: Check device logs and error reports

### Testing Issues
- Flaky tests: Ensure proper Setup/TearDown
- Slow tests: Mock dependencies and avoid Unity operations
- Test isolation: Clean up static state between tests

## Conclusion

This document serves as a comprehensive guide for developing the BeerRun Unity iOS game using test-driven development practices. Always prioritize writing tests first, follow iOS best practices, and maintain high code quality standards throughout development.

Remember: **Red-Green-Refactor** is not just a methodology, it's a mindset that leads to more reliable, maintainable, and enjoyable game development.